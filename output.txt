using System.Collections.Generic;
using System.IO;
using System.Numerics;
using System.Text;
using System.Collections;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System;
/*
ActionsBuilder.cs
*/


static class ActionsBuilder
{
    const string BUILD = "BUILD";
    const string MOVE = "MOVE";
    const string SPAWN = "SPAWN";
    const string WAIT = "WAIT";
    const string MESSAGE = "MESSAGE";

    public static string Build (Field field)
    {
        return $"{BUILD} {field.PositionLog()};";
    }

    public static string Spawn (Field field, int amount)
    {
        return $"{SPAWN} {amount} {field.PositionLog()};";
    }

    public static string Move (Field from, Field to, int amount)
    {
        int secureAmount = SecureAmount(from, amount);

        return $"{MOVE} {secureAmount} {from.PositionLog()} {to.PositionLog()};";
    }

    public static string Move (Field from, int toX ,int toY , int amount)
    {
        int secureAmount = SecureAmount(from, amount);

        return $"{MOVE} {secureAmount} {from.PositionLog()} {toX} {toY};";
    }

    public static string Move (byte fromX ,byte fromY , byte toX ,byte toY , int amount)
    {
        return $"{MOVE} {amount} {fromX} {fromY} {toX} {toY};";
    }

    static int SecureAmount(Field from,  int amount){
        int secureAmount = amount;
        if(amount > from.units)
        {
            Console.Error.WriteLine($"!!! Tried to move from {from.PositionLog()} {amount}, autoReduced!");
            secureAmount = from.units;
        }
        return secureAmount;
    }

    public static string Wait ()
    {
        return WAIT;
    }

}


/*
Consts.cs
*/

static class Consts
{
    public static int BuildCost = 10;
    public static int IncomePerRound = 10;
}


/*
direction.cs
*/

struct Direction{
    public sbyte X;
    public sbyte Y;

    public Direction(sbyte x, sbyte y)
    {
        X = x;
        Y = y;
    }
    public static implicit operator (sbyte x, sbyte y)(Direction direction)
    {
        return (direction.X,direction.Y);
    }
}


/*
Field.cs
*/


struct Field
{
    public byte X;
    public byte Y;
    public byte scrapAmount;
    public bool mine;
    public bool enemies;
    public byte units;
    public bool recycler;
    public bool canBuild;
    public bool canSpawn;
    public bool inRangeOfRecycler;
    public byte TotalCollectableScrap;
    public bool SuroundingStays;
    public bool GoodSpawn;
    public bool OffenceSpawn;
    public int Pressure;
    public int PressureChangeForecast;

    static Direction[] MoveDirectionsLeftToRight = new Direction[]
    {
        new Direction(-1, 0), new Direction(1, 0),new Direction(0, -1), new Direction(0, 1)
    };
    static Direction[] MoveDirectionsRightToLeft = new Direction[]
    {
        new Direction(1, 0), new Direction(-1, 0),new Direction(0, -1), new Direction(0, 1)
    };

    public Field(byte x, byte y, byte scrapAmount, bool mine, bool enemies, byte units, bool recycler, bool canBuild, bool canSpawn, bool inRangeOfRecycler)
    {
        X = x;
        Y = y;
        this.scrapAmount = scrapAmount;
        this.mine = mine;
        this.enemies = enemies;
        this.units = units;
        this.recycler = recycler;
        this.canBuild = canBuild;
        this.canSpawn = canSpawn;
        this.inRangeOfRecycler = inRangeOfRecycler;
        TotalCollectableScrap = 0;
        SuroundingStays = false;
        GoodSpawn = false;
        OffenceSpawn = false;
        Pressure = 0;
        PressureChangeForecast = 0;
    }

    public static int SortByTotalCollectableScrap(Field x, Field y)
    {
        return x.TotalCollectableScrap.CompareTo(y.TotalCollectableScrap) * -1;
    }

    public static int SortByPressure(Field x, Field y)
    {
        return x.Pressure.CompareTo(y.Pressure);
    }

    public static int SortByGameDirection(Field x, Field y)
    {
        int xSort = x.X.CompareTo(y.X);
        xSort *= Player.PlayDirection * -1;
        return xSort;
    }

    public string PositionLog()
    {
        return $"{X} {Y}";
    }

    public string Info()
    {
        return $"{PositionLog()} scrap {scrapAmount} mine {mine} enemies {enemies} units {units} recycler {recycler} canBuild {canBuild}";
    }

    public List<Field> GetPossibleMoveDirection(GameBoard board, bool invertDirection = false)
    {
        List<Field> possibleDirection = new();
        int Direction = Player.PlayDirection;
        if(invertDirection)
            Direction *= -1;
        Direction[] MoveDirections = Direction == -1 ? MoveDirectionsLeftToRight : MoveDirectionsRightToLeft;
        foreach (Direction direction in MoveDirections)
        {
            byte x = (byte)(X + direction.X);
            byte y = (byte)(Y + direction.Y);
            if (!UTIL.CheckForInBound(x, y))
                continue;
            Field targetField = board[x, y];
            if (targetField.scrapAmount != 0 && !targetField.recycler)
            {
                possibleDirection.Add(targetField);
            }
        }

        return possibleDirection;
    }

    public bool GetFieldInDirection(bool AttackDirection, GameBoard gameboard, out Field directionField )
    {
        int direction = AttackDirection ? Player.PlayDirection : Player.PlayDirection * -1;
        int x = X + direction;
        bool inbound = UTIL.CheckForInBound(x, Y);
        directionField = gameboard[0,0];
        if(!inbound)
        {
            return false;
        }
        else
        {
            directionField = gameboard[x,Y];
            return true;
        }
    }



    static public bool operator ==(Field self, Field other)
    {
        return self.X == other.X && self.Y == other.Y;
    }

    static public bool operator !=(Field self, Field other)
    {
        return self.X != other.X || self.Y != other.Y;
    }

    public override int GetHashCode()
    {
        int x = X;
        int y = Y;
        int hash = x << 8 | y;
        return hash;
    }

    public override bool Equals([NotNullWhen(true)] object? obj)
    {
        if (obj == null)
            return false;
        if (typeof(Field) != obj.GetType())
            return false;
        Field other = (Field)obj;

        return X == other.X && Y == other.Y;
    }
}


/*
GameBoard.cs
*/


class GameBoard
{
    public static int width, height;
    public Field[,] fields;

    public HashSet<Field> MyFields;
    public HashSet<Field> EnemieFields;
    public HashSet<Field> FreeField;

    public HashSet<Field> EnemieBorderFields;
    public HashSet<Field> MyBorderFields;

    public int MyMatter;

    public List<Field> MyUnits;
    public List<Field> EnemyUnits;

    public string CommandGettingHere;
    public float score;

    public List<Action> CurrentCommands = new List<Action>();

    public Field this[int x, int y]
    {
        get
        {
            return fields[x, y];
        }
        set { fields[x, y] = value; }
    }

    public GameBoard(Field[,] fields)
    {
        this.fields = fields;
        MyFields = new();
        EnemieFields = new();
        FreeField = new();
        MyUnits = new();
        MyBorderFields = new();
        EnemieBorderFields = new();
        CommandGettingHere = "";
        MyMatter = 0;
        EnemyUnits = new();
    }

    public GameBoard(GameBoard board)
    {
        fields = (Field[,])board.fields.Clone();
        MyFields = board.MyFields;
        EnemieFields = new HashSet<Field>();
        FreeField = new HashSet<Field>();
        MyUnits = new List<Field>();
        CommandGettingHere = board.CommandGettingHere;
        MyMatter = board.MyMatter;
        CurrentCommands = new List<Action>();
    }

    public static int SortByScore(GameBoard board1, GameBoard board2)
    {
        return board1.score.CompareTo(board2.score) * -1;
    }

    public void Analize()
    {
        MyFields.Clear();
        EnemieFields.Clear();
        FreeField.Clear();
        MyBorderFields.Clear();
        EnemieBorderFields.Clear();

        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                Field field = fields[x, y];
                //Console.Error.Write(field.GetHashCode()+", ");

                if (field.scrapAmount == 0)
                    continue;

                GetSurroundingValues(ref field);

                fields[x, y] = field;

                if (field.mine)
                {
                    MyFields.Add(field);
                    if (field.units >= 1)
                    {
                        MyUnits.Add(field);
                    }
                }
                else if (field.enemies)
                {
                    if(field.units >= 1)
                        EnemyUnits.Add(field);
                    EnemieFields.Add(field);
                }
                else
                    FreeField.Add(field);
            }
        }

        CalculateScore();
    }

    private void CalculateScore()
    {
        int verticalScore = VerticalScore();

        int pureScore = MyFields.Count - EnemieFields.Count;
        score = pureScore + verticalScore / 2;
        //Console.Error.WriteLine ($"Current Score : {score} : MyFields {MyFields.Count} , Enemie {EnemieFields.Count}, MyUnits :{MyUnits.Count}");
    }

    int VerticalScore()
    {
        HashSet<Field> set = new(); // use Set for perfomance unique
        foreach (var unit in MyUnits)
        {
            for (byte vPos = unit.X; vPos >= 0 && vPos < width; vPos = (byte)(vPos + Player.PlayDirection * -1)) // Looking back to my base
            {
                if (fields[vPos, unit.Y].scrapAmount != 0) // take fields wich i can own into account
                {
                    bool isNew = set.Add(fields[vPos, unit.Y]); // add unique to set
                    if (isNew) // if we found one we can skip the rest of the line
                        break;
                }
            }
        }
        set.ExceptWith(MyFields);
        return set.Count;
    }

    public List<Field> GetHigherSurroundingsFields()
    {
        List<Field> mine = new List<Field>(MyFields);
        mine = mine.FindAll((c) => { return c.SuroundingStays; });
        return mine;
    }

    public List<Field> GetSpawnFields()
    {
        List<Field> spawns = new();
        foreach (Field f in MyFields)
            if (f.GoodSpawn)
                spawns.Add(f);
        return spawns;
    }

    void GetSurroundingValues(ref Field field)
    {
        field.TotalCollectableScrap = field.scrapAmount;
        field.SuroundingStays = true;
        field.Pressure = (field.mine) ? field.units : -field.units;
        foreach (Field direction in field.GetPossibleMoveDirection(this))
        {
            CheckNeighbour(ref field, direction);
        }
    }

    private void CheckNeighbour(ref Field field, Field neighbour)
    {
        //Max Amount Clamped by own scrapAmount
        field.TotalCollectableScrap += Math.Clamp(neighbour.scrapAmount, (byte)0, field.scrapAmount);

        if (field.mine && neighbour.enemies)
            field.Pressure -= neighbour.units;
        if (field.enemies && neighbour.mine)
            field.Pressure += neighbour.units;

        if (!CheckForHigherSurrounding(field, neighbour))
            field.SuroundingStays = false;
        if(field.canSpawn && neighbour.enemies)
            field.OffenceSpawn = true;
        if (field.canSpawn && !neighbour.mine && !neighbour.enemies)
        {
            field.GoodSpawn = true;
        }

        if (field.mine && !neighbour.mine)
        {
            if (!MyBorderFields.Contains(neighbour))
                MyBorderFields.Add(neighbour);
        }

        if (field.enemies && !neighbour.enemies)
        {
            if (!EnemieBorderFields.Contains(neighbour))
                EnemieBorderFields.Add(neighbour);
        }
    }

    bool CheckForHigherSurrounding(Field field, Field surroundedField)
    {
        if (surroundedField.scrapAmount != 0 && surroundedField.scrapAmount <= field.scrapAmount)
            return false;
        else
            return true;
    }

    internal void ExecuteCommands(List<Action> moveCommands)
    {
        CurrentCommands = moveCommands;

        foreach (Action action in moveCommands)
        {
            action.Execute(this);
        }
        Analize(); // TODO : Coud move Everthing into Execute to not iterate over all Fields again
        //TODO: Increase Metal
        //TODO: Haverst Matel from colletors
    }

    public string GetBuildString()
    {
        string command = "";
        // foreach (Action action in CurrentCommands)
        // {
        //     command += action.Build();
        // }
        return command;
    }

    // internal Field NextFree (Vector2 myUnit)
    // {
    //     List<Field> notmine = new List<Field> (EnemieFields);
    //     notmine.AddRange (FreeField);
    //     float MinDistance = float.MaxValue;
    //     Field clostest = new Field ();
    //     foreach (Field field in notmine)
    //     {
    //         float distance = Vector2.Distance (field.position, myUnit);
    //         if (distance < MinDistance)
    //         {
    //             MinDistance = distance;
    //             clostest = field;
    //         }
    //     }
    //     return clostest;
    // }
}


/*
mainCode.cs
*/

//8236584684887423000 wide big nopoint
//4922755871518232000 big point flank

//IMPROVEMENTS:
//1. When calc Way towards AttackPoint mark fields as steped
//1.1 Compare ways with the same length how many newStep fields its creates

//Calculate how much points a move of a enemy will cost me and prio spawn
class Player
{
    public static sbyte PlayDirection = 1; // 1 to right , -1 to left
    public static Field MyBasePosition;
    public static Field EnemyBasePosition;
    public static byte middle;
    public static bool Init = false;
    public static int GameStep = 0;
    public static List<Field> AttackLine = new List<Field>(50);

    static (sbyte, sbyte)[] MoveDirections = new (sbyte, sbyte)[]
    {
        (0, -1), (0, 1), (-1, 0), (1, 0)
    }; //up,down,left,right
    public static Random random = new Random();
    static void Main(string[] args)
    {
        string[] inputs;
        inputs = Console.ReadLine().Split(' ');
        int width = int.Parse(inputs[0]);
        int height = int.Parse(inputs[1]);
        GameBoard.height = height;
        GameBoard.width = width;

        middle = (byte)(width / 2);
        Field[,] fields = new Field[width, height];
        int SurroundingCounter = 10;
        GamePhase gamePhase = new EarlyGame();

        // game loop
        while (true)
        {
            GameStep++;
            inputs = Console.ReadLine().Split(' ');
            int myMatter = int.Parse(inputs[0]);
            int oppMatter = int.Parse(inputs[1]);
            fields = new Field[width, height];
            int complexity = 1;
            for (byte y = 0; y < height; y++)
            {
                for (byte x = 0; x < width; x++)
                {
                    inputs = Console.ReadLine().Split(' ');
                    byte scrapAmount = byte.Parse(inputs[0]);
                    SByte owner = SByte.Parse(inputs[1]); // 1 = me, 0 = foe, -1 = neutral
                    bool mine = owner == 1;
                    bool enemies = owner == 0;
                    byte units = byte.Parse(inputs[2]);
                    bool recycler = int.Parse(inputs[3]) == 1;
                    bool canBuild = int.Parse(inputs[4]) == 1;
                    bool canSpawn = int.Parse(inputs[5]) == 1;
                    bool inRangeOfRecycler = int.Parse(inputs[6]) == 1;
                    fields[x, y] = new Field(x, y, scrapAmount, mine, enemies, units, recycler, canBuild, canSpawn, inRangeOfRecycler);
                }
            }

            GameBoard gameBoard = new GameBoard(fields);
            gameBoard.MyMatter = myMatter;
            gameBoard.Analize();
            //DebugPressureSystem(width, height, fields);

            if (!Init)
            {
                FindMatchData(gameBoard);
            }
            //UpdateAttackLine(gameBoard);
            if (gamePhase.CheckTransition(gameBoard))
                gamePhase = gamePhase.Transition();

            // foreach (Field attackPoint in AttackLine)
            //     Console.Error.WriteLine($"AttackPoint {attackPoint.PositionLog()}");
            // if (gamePhase.CheckTransition())
            //     gamePhase = gamePhase.Transition();
            gamePhase.Execute(gameBoard);

            //nextGameBoards.Clear();
            //gameBoard.CommandGettingHere = command;

            //Console.WriteLine (nextGameBoards[0].GetBuildString ());

        }
    }

    private static void DebugPressureSystem(int width, int height, Field[,] fields)
    {
        for (byte y = 0; y < height; y++)
        {
            for (byte x = 0; x < width; x++)
            {
                Field field = fields[x, y];
                if (field.scrapAmount == 0)
                    Console.Error.Write(" -");
                else
                    if (field.recycler)
                {
                    Console.Error.Write($" x");
                }
                else
                    Console.Error.Write($"{field.Pressure}".PadLeft(2));
            }
            Console.Error.WriteLine();
        }
    }

    static void UpdateAttackLine(GameBoard gameBoard)
    {
        AttackLine.Clear();

        HashSet<Field> myVisitedFields = new HashSet<Field>();
        HashSet<Field> myCurrentFields = new HashSet<Field>();
        HashSet<Field> enemyVisitedFields = new HashSet<Field>();
        HashSet<Field> enemyCurrentFields = new HashSet<Field>();
        HashSet<Field> MyDisscoverdField = new();
        HashSet<Field> EnemyDisscoverdField = new();

        foreach (var item in gameBoard.MyBorderFields)
        {
            myCurrentFields.Add(item);
            myVisitedFields.Add(item);
        }

        foreach (var item in gameBoard.EnemieBorderFields)
        {
            Console.Error.Write(item.PositionLog()+ ", ");
            enemyCurrentFields.Add(item);
            enemyVisitedFields.Add(item);
        }
        Console.Error.WriteLine("----");

        while (myCurrentFields.Count != 0)
        {
            MyDisscoverdField.Clear();
            EnemyDisscoverdField.Clear();

            foreach (Field item in myCurrentFields)
            {
                foreach(Field newField in item.GetPossibleMoveDirection(gameBoard))
                {
                    if(!myVisitedFields.Contains(newField))
                    {
                        if(newField.enemies )
                            AttackLine.Add(newField);

                        else if(!newField.mine && !MyDisscoverdField.Contains(newField))
                            MyDisscoverdField.Add(newField);

                        myVisitedFields.Add(newField);
                    }
                }
            }
            foreach (Field item in enemyCurrentFields)
            {
                foreach(Field newField in item.GetPossibleMoveDirection(gameBoard))
                {
                    if(!enemyVisitedFields.Contains(newField)&&!myVisitedFields.Contains(newField))
                    {
                        if(newField.mine)
                        {
                        }
                        else if(!newField.enemies && !EnemyDisscoverdField.Contains(newField))
                        {
                            Console.Error.Write(newField.PositionLog()+newField.enemies+ ", ");
                            EnemyDisscoverdField.Add(newField);
                        }
                        enemyVisitedFields.Add(newField);
                    }
                }
            }
            List<Field> intersections = MyDisscoverdField.Intersect(EnemyDisscoverdField).ToList();
            AttackLine.AddRange(intersections);

            MyDisscoverdField.ExceptWith(intersections);
            EnemyDisscoverdField.ExceptWith(intersections);

            myCurrentFields.Clear();
            foreach (var item in MyDisscoverdField)
            {
                myCurrentFields.Add(item);
            }

            enemyCurrentFields.Clear();
            foreach (var item in EnemyDisscoverdField)
            {
                enemyCurrentFields.Add(item);
            }
        }
    }

    static List<GameBoard> nextGameBoards = new();

    static void PopulateGameBoards(GameBoard board, int depth)
    {
        for (int i = 0; i <= 100; i++)
        {
            GameBoard next = new GameBoard(board);
            List<Action> moveCommands = new();
            foreach (Field myUnit in board.MyUnits)
            {
                List<Field> possibleDirection = board[myUnit.X, myUnit.Y].GetPossibleMoveDirection(board);
                if (possibleDirection.Count == 0)
                    continue;
                Field direction = possibleDirection[random.Next(possibleDirection.Count)];

                //moveCommands.Add(new Move(myUnit.X, myUnit.Y, (byte)(myUnit.X + direction.x), (byte)(myUnit.Y + direction.y), myUnit.units));

                //moveCommands += ActionsBuilder.Move (myUnit.x, myUnit.y, (byte) (myUnit.x + direction.x), (byte) (myUnit.y + direction.y), myUnit.count);
            }

            //next.CurrentCommands = moveCommands;
            next.ExecuteCommands(moveCommands);
            nextGameBoards.Add(next);
        }
        nextGameBoards.Sort(GameBoard.SortByScore); // Maybe use directly sorted Structure ?

        // for (int i = 0; i < 10; i++)
        // {
        //     Console.Error.WriteLine($"{nextGameBoards[i].score} {nextGameBoards[i].GetBuildString()}");
        // }

    }

    private static void FindMatchData(GameBoard board)
    {
        Init = true;


        foreach (Field field in board.EnemieFields)
            if (field.units == 0)
                EnemyBasePosition = field;

        foreach (Field field in board.MyFields)
            if (field.units == 0)
                MyBasePosition = field;

        if (MyBasePosition.X >= middle)
            PlayDirection = -1;
        else
            PlayDirection = 1;

        AttackLine = GetAttackLine(board);
    }

    static List<Field> GetAttackLine(GameBoard gameBoard)
    {
        List<Field> attackPoints = new List<Field>();
        Field AttackPoint = gameBoard[Player.middle, Player.MyBasePosition.Y];
        for (int i = 0; i < GameBoard.height; i++)
        {
            bool inBoundUpper = UTIL.CheckForInBound(Player.middle, Player.MyBasePosition.Y + i);
            bool inBoundLower = UTIL.CheckForInBound(Player.middle, Player.MyBasePosition.Y - i);
            if (inBoundUpper)
            {
                Field field = gameBoard[Player.middle, Player.MyBasePosition.Y + i];
                if (field.scrapAmount != 0)
                    attackPoints.Add(field);
            }

            if (inBoundLower && i != 0)
            {
                Field field = gameBoard[Player.middle, Player.MyBasePosition.Y - i];
                if (field.scrapAmount != 0)
                    attackPoints.Add(field);
            }

        }

        return attackPoints;
    }


}


/*
Settings.cs
*/

static class Settings
{
    public static float maxTimeForCalc = 48;

    public static int OffsetToFindSpawn = 2;
    internal static int StartConquereAfterSteps = 10;
}


/*
UTIL.cs
*/

static class UTIL
{
    public static int Distance(Field a, Field b)
    {
        return Math.Abs(a.X - b.X) + Math.Abs(a.X - b.X);
    }

    public static int Distance(Field a, (int X, int Y) b)
    {
        return Math.Abs(a.X - b.X) + Math.Abs(a.X - b.X);
    }

    public static bool CheckForInBound(int x, int y)
    {
        return x >= 0 && y >= 0 && x < GameBoard.width && y < GameBoard.height;
    }

    public static Field GetFurthestField(List<Field> fields)
    {
        bool toTheRight = Player.PlayDirection == 1;
        int startIndex = toTheRight ? fields.Count - 1 : 0;
        int target = toTheRight ? 0 : fields.Count - 1;

        for(int i = startIndex; toTheRight && i >= 0 || !toTheRight && i <= fields.Count - 1; i+=Player.PlayDirection * -1)
        {
            if (fields[i].inRangeOfRecycler && fields[i].scrapAmount == 1)
                continue;
            return fields[i];
        }
        //FallBack
        if (Player.PlayDirection == 1)
            return fields[fields.Count - 1];
        else
            return fields[0];
    }
}


/*
Actions\Action.cs
*/

abstract class Action
{
    abstract public string Build ();
    abstract public void Execute (GameBoard board);

}


/*
Actions\Move.cs
*/

class Move : Action
{
    byte x, y, toX, toY, amount;

    public Move (byte x, byte y, byte toX, byte toY, byte amount)
    {
        this.x = x;
        this.y = y;
        this.toX = toX;
        this.toY = toY;
        this.amount = amount;
    }

    public override void Execute (GameBoard board)
    {
        Field newField = board[toX, toY];
        if (newField.scrapAmount == 0 || newField.recycler)
        {
            //Console.Error.WriteLine ($"IllegaleMove : {Build()}");
            return;
        }
        Field field = board[x, y];
        field.units -= amount;

        if (newField.enemies)
        {
            if (amount < newField.units)
                newField.units -= amount;
            else if (amount > newField.units)
            {
                newField.units = (byte) (amount - newField.units);
                newField.mine = true;
                newField.enemies = false;
            }
            else
            {
                newField.units = 0;
            }
        }
        else
        {
            newField.units = amount;
            newField.mine = true;
        }

        board[x, y] = field;
        board[toX, toY] = newField;
        //Console.Error.WriteLine ("Old :" + field.Info ());
        //Console.Error.WriteLine ("New :" + newField.Info ());
    }

    public override string Build ()
    {
        return "";
        //     return ActionsBuilder.Move (x, y, toX, toY, amount);
    }
}


/*
GamePhase\EarlyGame.cs
*/

class EarlyGame : GamePhase
{
    Dictionary<Field, int> AlreadySelectedUnits = new Dictionary<Field, int>();
    Dictionary<Field, int> NotSelectedUnits = new Dictionary<Field, int>();


    public override void Execute(GameBoard gameBoard)
    {
        base.Execute(gameBoard);
        AlreadySelectedUnits.Clear();
        NotSelectedUnits.Clear();

        foreach (Field field in gameBoard.MyUnits)
            NotSelectedUnits.Add(field, field.units);


        BuildSpeedUps();
        FlankDetection(true);
        FlankDetection(false);

        MoveFastestAttackPoint();

        Console.WriteLine(command);
    }



    void BuildSpeedUps()
    {
        if (gameBoard.MyMatter >= Consts.BuildCost)
        {
            List<Field> higherSurroundingFields = gameBoard.GetHigherSurroundingsFields();
            foreach (Field field in higherSurroundingFields)
            {
                if (field.canBuild && gameBoard.MyMatter >= Consts.BuildCost && field.TotalCollectableScrap >= 20)
                {
                    gameBoard.MyMatter -= 10;
                    command += ActionsBuilder.Build(field);
                }
            }
        }
    }
    void FlankDetection(bool Top)
    {
        int mostmyTopRow = Top ? myRowMappedUnits.Keys.Min() : myRowMappedUnits.Keys.Max();
        int enemieTopUnit = Top ? enemyRowMappedUnits.Keys.Min() : enemyRowMappedUnits.Keys.Max();
        if (Top)
            Console.Error.WriteLine($"My Top{mostmyTopRow} other Top{enemieTopUnit}");
        else
            Console.Error.WriteLine($"My Bottom{mostmyTopRow} other Bottom{enemieTopUnit}");

        if (mostmyTopRow == enemieTopUnit)
            return;
        Console.Error.WriteLine("Flank in Progress?");
        int myDefendingUnitIndex = Player.PlayDirection == 1 ? myRowMappedUnits[mostmyTopRow].Count - 1 : 0;
        Field DefendingUnit = myRowMappedUnits[mostmyTopRow][myDefendingUnitIndex];

        int AttackingUnitIndex = Player.PlayDirection == 1 ? enemyRowMappedUnits[enemieTopUnit].Count - 1 : 0;
        Field AttackingUnit = enemyRowMappedUnits[enemieTopUnit][AttackingUnitIndex];
        Console.Error.WriteLine($"Attacking Unit{AttackingUnit.PositionLog()} Def{DefendingUnit.PositionLog()}");

        HashSet<Field> myVisitedFields = new();
        HashSet<Field> myCurrentFields = new();
        HashSet<Field> myInspectList = new();

        HashSet<Field> enemyVisitedFields = new();
        HashSet<Field> enemyCurrentFields = new();
        HashSet<Field> enemyInspectList = new();

        Dictionary<Field, int> EnemyStepCounter = new();

        myCurrentFields.Add(DefendingUnit);
        enemyCurrentFields.Add(AttackingUnit);
        int step = 0;

        while (enemyCurrentFields.Count > 0)
        {
            foreach (Field f in enemyCurrentFields)
            {
                enemyVisitedFields.Add(f);
                EnemyStepCounter.Add(f, step);
                bool hasField = f.GetFieldInDirection(false, gameBoard, out Field moveField);

                if (!moveField.enemies && !enemyVisitedFields.Contains(moveField))
                    enemyInspectList.Add(moveField);


            }
            step++;
            enemyCurrentFields.Clear();

            foreach (Field f in enemyInspectList)
                enemyCurrentFields.Add(f);
            enemyInspectList.Clear();
        }
        step = 1;
        while (myCurrentFields.Count > 0)
        {
            foreach (Field f in myCurrentFields)
            {
                myVisitedFields.Add(f);
                foreach (Field moveField in f.GetPossibleMoveDirection(gameBoard))
                {
                    if (!moveField.mine && !myVisitedFields.Contains(moveField))
                        myInspectList.Add(moveField);

                    if (EnemyStepCounter.ContainsKey(moveField))
                    {
                        int stepBalance = EnemyStepCounter[moveField] - step;
                        if (stepBalance == 1 || stepBalance == 2)
                        {
                            Console.Error.WriteLine($"Defending at {moveField.PositionLog()}");
                            DefendFlank(DefendingUnit, moveField);
                            return;
                        }
                    }
                }

            }
            step++;
            myCurrentFields.Clear();
            foreach (Field f in myInspectList)
                myCurrentFields.Add(f);
            myInspectList.Clear();
        }
        //Watch border Lines where enemy has units and i dont have tiles
        //Add Counter on wich step wich field is reached
        //Substract counter on how much step i can reach the field
        // Sum is <0 im to late =0 collisition >0 im first
    }

    void DefendFlank(Field defendingUnit, Field defendField)
    {
        AlreadySelectedUnits.Add(defendingUnit, 1);
        NotSelectedUnits[defendingUnit]--;
        command += ActionsBuilder.Move(defendingUnit, defendField, 1);
    }

    void BuildArmee()
    {
        if (gameBoard.MyMatter >= Consts.BuildCost)
        {
            int max = rowMappedFields.Keys.Max();
            int min = rowMappedFields.Keys.Min();

            int bestIndexMax = Player.PlayDirection == 1 ? rowMappedFields[max].Count - 1 : 0;
            int bestIndexMin = Player.PlayDirection == 1 ? rowMappedFields[min].Count - 1 : 0;

            bool canSpawnOnBothSides = gameBoard.MyMatter >= Consts.BuildCost * 2;
            bool maxRowFree = (max != GameBoard.height - 1);
            bool minRowFree = (min != 0);

            Console.Error.WriteLine($"in {max} von {GameBoard.height - 1} = free {maxRowFree}");
            if (maxRowFree)
                if (canSpawnOnBothSides || !canSpawnOnBothSides && Player.GameStep % 2 == 0)
                    //if (!gameBoard.MyUnits.Contains (rowMappedFields[max][bestIndexMax]))
                    command += ActionsBuilder.Spawn(rowMappedFields[max][bestIndexMax], 1);

            if (minRowFree)
                if (canSpawnOnBothSides || !canSpawnOnBothSides && Player.GameStep % 2 == 1 && minRowFree)
                    //if (!gameBoard.MyUnits.Contains (rowMappedFields[min][bestIndexMin]))
                    command += ActionsBuilder.Spawn(rowMappedFields[min][bestIndexMin], 1);

        }
    }

    void MoveFastestAttackPoint()
    {

        //Console.Error.WriteLine("Update AttackLine");
        //EasyUpdateAttackLine();

        DynamicAttackLine();


        // toDO send all other to the next field / front

        // Find Point Symetry Attack Line
        // Update Frontline by unit movement
        //
        foreach (Field attackPoint in Player.AttackLine)
        {
            bool canSpawn = gameBoard.MyMatter >= Consts.BuildCost;
            Field bestAttackField = base.FindBestMoveOrSpawn(attackPoint, AlreadySelectedUnits, out Field moveTarget, canSpawn);
            if (attackPoint == bestAttackField)
                continue;
            bool found = AlreadySelectedUnits.TryGetValue(bestAttackField, out int sofarControlled);
            Console.Error.WriteLine($" Best Field {bestAttackField.PositionLog()} to {attackPoint.PositionLog()} {sofarControlled}");
            if (bestAttackField.units >= sofarControlled)
            {
                if (!AlreadySelectedUnits.Keys.Contains(bestAttackField))
                    AlreadySelectedUnits.Add(bestAttackField, 0);
                AlreadySelectedUnits[bestAttackField]++;

                UpdateNotSelected(NotSelectedUnits, bestAttackField);

                command += ActionsBuilder.Move(bestAttackField, moveTarget, 1);
            }
            else
            {
                gameBoard.MyMatter -= Consts.BuildCost;
                command += ActionsBuilder.Spawn(bestAttackField, 1);
            }
        }

        foreach (var field in NotSelectedUnits)
        {
            if (field.Value >= 1)
            {
                Console.Error.WriteLine("Sending" + field.Key.PositionLog() + "to the front");
                foreach (Field f in Player.AttackLine)
                {
                    Console.Error.WriteLine("AttackLine" + f.PositionLog());
                    if (f.Y == field.Key.Y)
                        command += ActionsBuilder.Move(field.Key, f, field.Value);

                }
                if (enemyRowMappedUnits.ContainsKey(field.Key.Y))
                {
                    command += ActionsBuilder.Move(field.Key, enemyRowMappedUnits[field.Key.Y][0], field.Value);
                }
            }
        }
    }

    private static void UpdateNotSelected(Dictionary<Field, int> NotSelectedUnits, Field bestAttackField)
    {
        bool foundNotSelected = NotSelectedUnits.TryGetValue(bestAttackField, out int count);
        if (foundNotSelected)
            NotSelectedUnits[bestAttackField]--;
        else
        {
            foreach (var field in NotSelectedUnits.Keys)
                if (field == bestAttackField)
                    NotSelectedUnits[field]--;
        }
    }

    int L2Distance(Field field, Field other)
    {
        return Math.Abs(field.X - other.X) + Math.Abs(field.Y - other.Y);
    }

    void EasyUpdateAttackLine()
    {
        if (OneUnitReachedAttackLine())
        {
            //Console.Error.WriteLine("Move AttackLine");
            List<Field> newAttackLine = new List<Field>();
            foreach (Field item in Player.AttackLine)
            {
                Field newField = gameBoard[item.X + Player.PlayDirection, item.Y];
                newAttackLine.Add(newField);
            }
            Player.AttackLine = newAttackLine;
        }
    }

    bool OneUnitReachedAttackLine()
    {
        foreach (Field f in gameBoard.MyUnits)
        {
            if (Player.AttackLine.Contains(f))
            {
                Console.Error.WriteLine("Found");
                return true;
            }
        }
        Console.Error.WriteLine("Not Found");
        return false;
    }
    Dictionary<Field, (Field source, int steps, int newFields)> MovementMap = new();
    void DynamicAttackLine()
    {
        MovementMap.Clear();
        HashSet<Field> VisitedFields = new();
        HashSet<Field> CurrentFields = new(gameBoard.EnemyUnits.Concat(gameBoard.MyUnits));
        HashSet<Field> InspectList = new();
        Player.AttackLine.Clear();
        int Step = 1;
        while (CurrentFields.Count != 0)
        {
            foreach (Field currentField in CurrentFields)
            {
                foreach (Field checkField in currentField.GetPossibleMoveDirection(gameBoard, currentField.enemies))
                {
                    //Console.Error.Write($" {checkField.PositionLog()}, ");
                    bool alreadyDiscoverd = MovementMap.ContainsKey(checkField);
                    Field discoverdField = checkField;//copy field
                    discoverdField.mine = currentField.mine;
                    discoverdField.enemies = currentField.enemies;

                    if (alreadyDiscoverd)
                    {
                        Field AlreadyDiscoverdField = MovementMap.Keys.First<Field>((f) => { return f == discoverdField; });
                        if (discoverdField == AlreadyDiscoverdField)
                        {
                            Console.Error.Write("-");
                            if (discoverdField.mine && AlreadyDiscoverdField.enemies)
                            {
                                Console.Error.WriteLine("found collision" + discoverdField.PositionLog());
                                Player.AttackLine.Add(discoverdField);
                            }
                        }
                    }
                    else
                    {
                        InspectList.Add(discoverdField);
                        MovementMap.Add(discoverdField, (currentField, Step, 0));
                    }
                }
                VisitedFields.Add(currentField);
            }
            CurrentFields.Clear();
            foreach (Field item in InspectList)
            {
                CurrentFields.Add(item);
            }
            InspectList.Clear();
            Console.Error.WriteLine($"Step {Step}");
            Step++;
        }
        //TODO: Implement Step like progress for the whole map

    }

    void Move()
    {
        foreach (List<Field> fields in myRowMappedUnits.Values)
        {
            bool first = true;
            if (Player.PlayDirection == 1)
                fields.Reverse();

            foreach (Field field in fields)
            {
                int AwayCenterDirection = Math.Clamp(field.Y.CompareTo(Player.MyBasePosition.Y), -1, 1);
                Console.Error.WriteLine($"base at {Player.MyBasePosition.Y}: {field.PositionLog()} {AwayCenterDirection}");
                for (int i = 0; i < field.units; i++)
                {
                    //TODO LOOP as long as Fields are not possible
                    if (first)
                    {
                        first = false;
                        command += ActionsBuilder.Move(field, field.X + Player.PlayDirection, field.Y, 1);
                    }
                    else
                    {
                        first = true;
                        //Assume the way is blocked so search
                        Field TargetField = gameBoard[field.X, field.Y + AwayCenterDirection];
                        bool found = FindNextFreeFieldInRow(TargetField, out Field newTarget);
                        if (found)
                            command += ActionsBuilder.Move(field, field.X, field.Y + AwayCenterDirection, 1);
                        else
                            Console.Error.WriteLine("EndReached");

                    }
                }
            }
        }

        //moveCommands += ActionsBuilder.Move (myUnit.x, myUnit.y, (byte) (myUnit.x + direction.x), (byte) (myUnit.y + direction.y), myUnit.count);
    }

    bool FindNextFreeFieldInRow(Field field, out Field newTarget)
    {
        newTarget = field;
        for (int x = field.X; x >= 0 && x < GameBoard.width; x += Player.PlayDirection)
        {
            Field TargetField = gameBoard[x, field.Y];
            if (TargetField.mine || TargetField.scrapAmount == 0)
            {
                newTarget = TargetField;
                return true;
            }
        }
        return false;
    }

    public override bool CheckTransition(GameBoard gameBoard)
    {
        List<Field> myBorderFields = new List<Field>(25);
        foreach (Field field in gameBoard.MyFields)
        {
            foreach (Field borderField in field.GetPossibleMoveDirection(gameBoard))
            {
                if (borderField.enemies)
                    return true;
            }
        }
        return false;
    }

    public override GamePhase Transition()
    {
        MidGame midGame = new MidGame();
        return midGame;
    }
}


/*
GamePhase\GamePhase.cs
*/

class GamePhase
{
    protected string command = "";
    protected GameBoard gameBoard;

    protected Dictionary<int, List<Field>> myRowMappedUnits = new (GameBoard.height);
    protected Dictionary<int, List<Field>> enemyRowMappedUnits = new (GameBoard.height);
    protected Dictionary<int, List<Field>> rowMappedFields = new (GameBoard.height);

    virtual public void Execute(GameBoard board)
    {
        this.gameBoard = board;

        RowMapMyUnits();
        RowMapMyFields();
        RowMapEnemyUnits();
        command = "";
    }

    virtual public bool CheckTransition(GameBoard gameBoard)
    {
        return false;
    }

    virtual public GamePhase Transition()
    {
        return this;
    }

    protected void RowMapMyUnits()
    {
        myRowMappedUnits.Clear();

        foreach (Field myUnit in gameBoard.MyUnits)
        {
            if (!myRowMappedUnits.ContainsKey(myUnit.Y))
                myRowMappedUnits.Add(myUnit.Y, new List<Field>());
            myRowMappedUnits[myUnit.Y].Add(myUnit);
        }
    }
    protected void RowMapEnemyUnits()
    {
        enemyRowMappedUnits.Clear();

        foreach (Field enemyUnit in gameBoard.EnemyUnits)
        {
            if (!enemyRowMappedUnits.ContainsKey(enemyUnit.Y))
                enemyRowMappedUnits.Add(enemyUnit.Y, new List<Field>());
            enemyRowMappedUnits[enemyUnit.Y].Add(enemyUnit);
        }
    }

    protected void RowMapMyFields()
    {
        rowMappedFields.Clear();

        foreach (Field field in gameBoard.MyFields)
        {
            if (!rowMappedFields.ContainsKey(field.Y))
                rowMappedFields.Add(field.Y, new List<Field>());
            rowMappedFields[field.Y].Add(field);
        }
    }

    protected Field FindBestMoveOrSpawn(Field AttackField, Dictionary<Field, int> AlreadySelectedUnits, out Field moveTarget, bool withSpawn = true)
    {
        HashSet<Field> visitedFields = new HashSet<Field>();
        HashSet<Field> currentFields = new HashSet<Field>();
        moveTarget = AttackField;
        currentFields.Add(AttackField);
        bool found = false;
        HashSet<Field> inspectList = new();
        Dictionary<Field, int> spawnList = new();
        while (!found)
        {
            inspectList.Clear();

            foreach (Field field in currentFields)
            {
                //Otp could have an Defensive Mode where Playdirection is take into account
                foreach (Field checkField in field.GetPossibleMoveDirection(gameBoard))
                {

                    int openUnitCount = checkField.units;
                    if (AlreadySelectedUnits.Keys.Contains(checkField))
                        openUnitCount -= AlreadySelectedUnits[checkField];

                    if (checkField.mine && openUnitCount >= 1)
                    {
                        moveTarget = field;
                        return checkField;
                    }
                    if (withSpawn && checkField.mine && !spawnList.Keys.Contains(checkField))
                        spawnList.Add(checkField, Settings.OffsetToFindSpawn);
                    if (!visitedFields.Contains(checkField) && !inspectList.Contains(checkField))
                        inspectList.Add(checkField);
                }
                visitedFields.Add(field);
            }

            currentFields.Clear();
            foreach (Field field in inspectList)
            {
                currentFields.Add(field);
            }

            if (withSpawn)
            {
                foreach (var spawn in spawnList)
                {
                    if (spawn.Value == 0)
                        return spawn.Key;
                    spawnList[spawn.Key] = spawn.Value - 1;
                }
            }

            if (currentFields.Count == 0)
                found = true;
        }
        Console.Error.WriteLine($"No way found to {AttackField.PositionLog()}");
        return AttackField;
    }


}


/*
GamePhase\MidGame.cs
*/

class MidGame : GamePhase
{
    Dictionary<Field, int> controlledUnits = new Dictionary<Field, int> ();
    int nothingChangedCounter = 0;
    int oldPoints = 0;
    Field conquereUnit;
    bool Conquering = false;
    private bool topClosed = false;
    private bool bottomClosed = false;

    public override void Execute (GameBoard gameBoard)
    {
        base.Execute (gameBoard);

        controlledUnits.Clear ();

        //DontCountFlankingUnitsForDefence ();
        ConquereMapOnStuck ();
        SaveUnits ();
        CloseBorders (controlledUnits);
        BuildDefense ();
        MoveIntoFreeFieldForward ();
        //TODO: keep an eye on overall Mattle to not get overrun

        DecideAction ();
        if (command == "")
            Console.WriteLine (ActionsBuilder.Wait ());
        else
            Console.WriteLine (command);
    }

    void DontCountFlankingUnitsForDefence ()
    {
        foreach (var row in myRowMappedUnits)
        {
            Field field = UTIL.GetFurthestField (row.Value);

            foreach (Field moveField in field.GetPossibleMoveDirection (gameBoard))
            {
                bool BackWards = field.X == moveField.X + Player.PlayDirection;
                if (!BackWards && !moveField.mine && !moveField.enemies)
                {
                    Console.Error.WriteLine($"Mark {field.PositionLog()} as Flank");
                    IncreasePressure (field, field.units);
                    break;
                }
            }
        }
    }

    private void SaveUnits ()
    {
        foreach (Field unit in gameBoard.MyUnits)
        {
            if (unit.scrapAmount == 1 && unit.inRangeOfRecycler)
                MoveAway (unit);
        }
    }

    private void MoveAway (Field unit)
    {
        List < (Field, int) > PrioList = new (4);
        foreach (Field f in unit.GetPossibleMoveDirection (gameBoard))
        {
            if (f.enemies && !f.recycler) // attack
            {
                PrioList.Add ((f, 1));
            }
            else if (!f.enemies && !f.mine) // move to free
            {
                PrioList.Add ((f, 2));
            }
            else //justsave
            {
                int prio = f.X == unit.X ? 3 : 4;
                PrioList.Add ((f, prio));
            }
        }
        PrioList.Sort ((x1, x2) => { return x1.Item2.CompareTo (x2.Item2); });

        foreach ((Field, int) f in PrioList)
        {
            Console.Error.WriteLine ($"Save {unit.PositionLog()} to {f.Item1.PositionLog()} with Prio {f.Item2} ");
        }
        if (PrioList.Count >= 1)
        {
            controlledUnits.Add (unit, unit.units);
            command += ActionsBuilder.Move (unit, PrioList[0].Item1, unit.units);
        }

    }

    void MoveIntoFreeFieldForward ()
    {
        foreach (var row in myRowMappedUnits)
        {
            Field field = UTIL.GetFurthestField (row.Value);

            foreach (Field moveField in field.GetPossibleMoveDirection (gameBoard))
            {
                bool BackWards = field.X == moveField.X + Player.PlayDirection;
                if (!BackWards && !moveField.mine && !moveField.enemies)
                {
                    if (!controlledUnits.ContainsKey (moveField))
                        controlledUnits.Add (moveField, 0);
                    controlledUnits[moveField] = field.units;
                    IncreasePressure (field, field.units);
                    command += ActionsBuilder.Move (field, moveField, field.units);
                    Console.Error.WriteLine ($"Flank with {field.PositionLog()} to {moveField.PositionLog()}");
                    break;
                }
            }
        }
    }

    void BuildDefense ()
    {
        List<Field> defenceBuildSpawn = new List<Field> ();
        List<Field> offenceSpawn = new List<Field> ();
        List<Field> spawnAtFree = new ();
        foreach (Field buildField in gameBoard.MyFields)
        {
            if (buildField.GoodSpawn || buildField.OffenceSpawn)
            {
                Console.Error.WriteLine ($"At Field {buildField.PositionLog()} {buildField.Pressure + buildField.PressureChangeForecast } =  {buildField.Pressure}+{buildField.PressureChangeForecast}");
                if (buildField.Pressure + buildField.PressureChangeForecast < 0)
                    //if (buildField.canBuild)
                    defenceBuildSpawn.Add (buildField);
                // else
                //     offenceSpawn.Add(buildField);
                else if (buildField.Pressure == 0)
                {
                    if (buildField.OffenceSpawn)
                        offenceSpawn.Add (buildField);
                    if (buildField.GoodSpawn)
                        spawnAtFree.Add (buildField);
                }
                else
                {
                    offenceSpawn.Add (buildField);
                }

            }

        }
        //defenceBuildSpawn.Sort(Field.SortByPressure);
        List < (Field, int) > DefenceValues = AnalysePointsOnRisk (defenceBuildSpawn);
        foreach ((Field field, int pointLossScore) defence in DefenceValues)
        {
            Console.Error.WriteLine ($"Position {defence.field.PositionLog()} with Score: {defence.pointLossScore}");
        }
        foreach ((Field field, int pointLossScore) defence in DefenceValues)
        {
            if (gameBoard.MyMatter < Consts.BuildCost)
                break;
            if (defence.field.inRangeOfRecycler && defence.field.scrapAmount == 1)
                continue;
            if (defence.field.canBuild)
            {
                command += ActionsBuilder.Build (defence.field);
                Field f = gameBoard[defence.field.X, defence.field.Y];
                f.recycler = true;
                gameBoard[defence.field.X, defence.field.Y] = f;
                gameBoard.MyMatter -= Consts.BuildCost;
            }
            else if (defence.field.canSpawn)
            {
                int spawnUnits = Math.Max (defence.field.Pressure * -1, 1);
                command += ActionsBuilder.Spawn (defence.field, spawnUnits);
                DecreasePressure (defence.field);

                gameBoard.MyMatter -= Consts.BuildCost;
            }
        }

        offenceSpawn.Sort (Field.SortByGameDirection);
        //List<(Field, int)> DefenceUnitSpawnValues = AnalysePointsOnRisk(offenceSpawn,true);

        foreach (Field offence in offenceSpawn)
        {
            Console.Error.WriteLine ($"OffenceSpawn {offence.PositionLog()}");
        }

        if (gameBoard.MyMatter >= Consts.BuildCost && offenceSpawn.Count != 0)
        {
            int spawnableUnits = Math.Max ((gameBoard.MyMatter / Consts.BuildCost) / offenceSpawn.Count, 1);
            Console.Error.WriteLine (spawnableUnits + " ");
            foreach (Field offence in offenceSpawn)
            {
                if (gameBoard.MyMatter < Consts.BuildCost)
                    break;
                if (offence.inRangeOfRecycler && offence.scrapAmount == 1)
                    continue;
                Console.Error.WriteLine ("OffenceSpawn At" + offence.PositionLog ());
                command += ActionsBuilder.Spawn (offence, spawnableUnits);
                DecreasePressure (offence);
                gameBoard.MyMatter -= Consts.BuildCost * spawnableUnits;
            }
        }

        spawnAtFree.Sort (Field.SortByGameDirection);
        foreach (Field field in spawnAtFree)
        {
            if (gameBoard.MyMatter < Consts.BuildCost)
                break;
            if (field.inRangeOfRecycler && field.scrapAmount == 1)
                continue;
            Console.Error.WriteLine ("Free Spawn At" + field.PositionLog ());

            command += ActionsBuilder.Spawn (field, 1);
            gameBoard.MyMatter -= Consts.BuildCost;
        }
    }

    void IncreasePressure (Field field, byte units)
    {
        int index = gameBoard.MyUnits.FindIndex (0, gameBoard.MyUnits.Count, (x) => { return x == field; });
        Console.Error.WriteLine ($"Searched for {field.PositionLog()} found at {index}");
        if (index == -1) //no units to influence
            return;
        gameBoard.MyFields.Remove (field);
        field.PressureChangeForecast -= units;

        gameBoard.MyFields.Add (field);
        gameBoard.MyUnits[index] = field;
        Console.Error.WriteLine ($"Set for {gameBoard.MyUnits[index].PositionLog()} foreCast {gameBoard.MyUnits[index].PressureChangeForecast}");
    }
    private void DecreasePressure (Field defence)
    {
        int index = gameBoard.MyUnits.FindIndex (0, gameBoard.MyUnits.Count, (x) => { return x == defence; });
        if (index == -1) //no units to influence
            return;
        Field target = gameBoard.MyUnits[index];
        target.PressureChangeForecast += 1;
        gameBoard.MyUnits[index] = target;
    }

    void DecideAction ()
    {
        foreach (Field unit in gameBoard.MyUnits)
        {
            int Pressure = unit.Pressure + unit.PressureChangeForecast;
            if (Pressure < 0)
            {
                Defence (unit);
            }

            if (Pressure > 0)
            {
                Attack (unit);
            }
            // if (unit.Pressure == 0)
            // {
            //     WaitPrepareAttack(unit);
            // }
        }
    }

    List < (Field, int) > AnalysePointsOnRisk (List<Field> fields)
    {
        List < (Field, int) > pointsAtRisk = new ();
        HashSet<Field> fieldCounted = new ();
        foreach (Field defendPoint in fields)
        {

            fieldCounted.Clear ();
            fieldCounted.Add (defendPoint);
            int points = 1; //the field it self

            bool inbound = defendPoint.GetFieldInDirection (true, gameBoard, out Field fieldInAttackDirection);
            bool horizontalAttack = inbound && fieldInAttackDirection.enemies && fieldInAttackDirection.units >= 1;
            bool inboundDefend = defendPoint.GetFieldInDirection (false, gameBoard, out Field fieldInDefendDirection);
            bool freeAreaBehindAttack = inboundDefend && !fieldInDefendDirection.enemies && !fieldInDefendDirection.mine;

            foreach (Field buildAroundField in defendPoint.GetPossibleMoveDirection (gameBoard))
            {
                if (buildAroundField.mine)
                {
                    points++; // field where i build gets destroyed
                    //check how much gets Destroyed by blocking
                    if (buildAroundField.canBuild || buildAroundField.canSpawn)
                        foreach (Field checkMyField in buildAroundField.GetPossibleMoveDirection (gameBoard))
                        {
                            bool notDefendPoint = checkMyField != defendPoint;
                            bool alreadyCounted = fieldCounted.Contains (checkMyField);
                            //TODO Check if Field is in my half or enemy half, or even a enemy field
                            //TODO Check my unit count may be i dont have to build
                            if (checkMyField.mine && notDefendPoint && !alreadyCounted && buildAroundField.scrapAmount >= checkMyField.scrapAmount)
                            {
                                fieldCounted.Add (checkMyField);
                                points++; // field gets destroyed
                            }
                        }
                }
                else
                {
                    if (horizontalAttack && buildAroundField == fieldInDefendDirection && freeAreaBehindAttack)
                        points += Player.PlayDirection == 1 ? GameBoard.width - buildAroundField.X : buildAroundField.X;
                }

            }
            if (horizontalAttack)
                points *= 2;
            Console.Error.WriteLine ($"DefendPoint {defendPoint.PositionLog()} would loose {points}");
            pointsAtRisk.Add ((defendPoint, points));
        }
        pointsAtRisk.Sort ((x, y) => { return x.Item2.CompareTo (y.Item2) * -1; });

        return pointsAtRisk;
    }

    private void CloseBorders (Dictionary<Field, int> controlledUnits)
    {
        bool canSpawn = gameBoard.MyMatter >= Consts.BuildCost;
        if (!rowMappedFields.ContainsKey (0) && !topClosed)
        {
            for (int i = 0; i < GameBoard.height; i++)
            {
                if (myRowMappedUnits.ContainsKey (i))
                {
                    Field closestUnit = myRowMappedUnits[i][0];
                    if (!controlledUnits.ContainsKey (closestUnit))
                    {
                        Console.Error.WriteLine ("Close Top Border With " + closestUnit.PositionLog ());
                        Field borderField = gameBoard.fields[closestUnit.X, 0];
                        while (borderField.scrapAmount == 0)
                        {
                            borderField = gameBoard.fields[closestUnit.X, borderField.Y + 1];
                        }
                        if (closestUnit == borderField)
                            topClosed = true;
                        else
                        {
                            controlledUnits.Add (closestUnit, 1);
                            command += ActionsBuilder.Move (closestUnit, borderField, 1);
                        }
                        break;
                    }
                }
                if (rowMappedFields.ContainsKey (i - 1))
                {
                    Field closestSpawn = UTIL.GetFurthestField (rowMappedFields[i - 1]);
                    Console.Error.WriteLine ("Close Top Border With new Spawn" + closestSpawn.PositionLog ());
                    command += ActionsBuilder.Spawn (closestSpawn, 1);
                    gameBoard.MyMatter -= Consts.BuildCost;
                    break;
                }
            }
        }

        if (!rowMappedFields.ContainsKey (GameBoard.height - 1) && !bottomClosed)
        {
            for (int i = GameBoard.height - 1; i >= 0; i--)
            {
                if (myRowMappedUnits.ContainsKey (i))
                {

                    Field closestUnit = UTIL.GetFurthestField (myRowMappedUnits[i]);
                    if (!controlledUnits.ContainsKey (closestUnit))
                    {
                        Console.Error.WriteLine ("Close Bot Border With " + closestUnit.PositionLog ());
                        controlledUnits.Add (closestUnit, 1);
                        Field borderField = gameBoard.fields[closestUnit.X, GameBoard.height - 1];
                        while (borderField.scrapAmount == 0)
                        {
                            borderField = gameBoard.fields[closestUnit.X, borderField.Y - 1];
                        }
                        if (closestUnit == borderField)
                            bottomClosed = true;
                        else
                        {
                            command += ActionsBuilder.Move (closestUnit, borderField, 1);
                        }
                        break;
                    }
                }
                if (rowMappedFields.ContainsKey (i + 1))
                {
                    Field closestSpawn = UTIL.GetFurthestField (rowMappedFields[i + 1]);
                    Console.Error.WriteLine ("Close Bot Border With new Spawn" + closestSpawn.PositionLog ());
                    command += ActionsBuilder.Spawn (closestSpawn, 1);
                    gameBoard.MyMatter -= Consts.BuildCost;
                    break;
                }
            }
        }
    }

    void Defence (Field unit)
    {
        if (unit.inRangeOfRecycler && unit.scrapAmount == 1)
            return;
        int mustSpawn = unit.Pressure * -1;

        if (Consts.BuildCost * mustSpawn <= gameBoard.MyMatter)
        {
            gameBoard.MyMatter -= Consts.BuildCost * mustSpawn;
            command += ActionsBuilder.Spawn (unit, mustSpawn);
        }
    }

    void WaitPrepareAttack (Field unit)
    {

    }

    void Attack (Field unit)
    {
        HashSet<Field> disscoverdFields = new ();
        HashSet<Field> currentFields = new ();
        HashSet<Field> visistedFields = new ();
        bool found = controlledUnits.TryGetValue (unit, out int alreadyUsed);
        int unitsLeft = (unit.units - alreadyUsed);
        if (unitsLeft <= 0)
            return;
        //Attack Nearest Enemy Field
        List<Field> possibleFields = new ();
        foreach (Field checkField in unit.GetPossibleMoveDirection (gameBoard))
        {
            disscoverdFields.Add (checkField);
            visistedFields.Add (checkField);

            if (checkField.enemies && unit.Pressure + unit.PressureChangeForecast > 0)
            {
                possibleFields.Add (checkField);
            }
        }
        if (possibleFields.Count >= 1)
        {
            SplittAttack (possibleFields, unit);
            return;
        }

        foreach (Field f in disscoverdFields)
            currentFields.Add (f);

        //Search for next Enemy field
        while (currentFields.Count > 0)
        {
            if (unitsLeft <= 0)
                return;
            foreach (Field f in currentFields)
            {
                visistedFields.Add (f);
                foreach (Field checkField in f.GetPossibleMoveDirection (gameBoard))
                {
                    //TODO: If two enemy fields are possible try to splitt up
                    if (checkField.enemies)
                    {
                        unitsLeft -= unit.Pressure;
                        Console.Error.WriteLine ($"{unit.PositionLog()} to {checkField.PositionLog()}");
                        command += ActionsBuilder.Move (unit, checkField, unit.Pressure);
                        return;
                    }
                    if (!visistedFields.Contains (checkField) &&
                        !disscoverdFields.Contains (checkField))
                        disscoverdFields.Add (checkField);
                }

            }
            currentFields.Clear ();

            foreach (Field f in disscoverdFields)
                currentFields.Add (f);
            disscoverdFields.Clear ();
        }
        foreach (Field lastFree in visistedFields)
        {
            if (!lastFree.mine)
            {
                command += ActionsBuilder.Move (unit, lastFree, unit.Pressure);
                return;
            }
        }
    }

    void SplittAttack (List<Field> possibleAttackFields, Field targetUnit)
    {
        int unitsPerField;
        int rest = targetUnit.PressureChangeForecast;
        if (possibleAttackFields.Count == 1)
            unitsPerField = targetUnit.Pressure;
        else
        {
            unitsPerField = (targetUnit.Pressure + targetUnit.PressureChangeForecast) / possibleAttackFields.Count;
            rest = (targetUnit.Pressure + targetUnit.PressureChangeForecast) % possibleAttackFields.Count;
        }

        Console.Error.WriteLine ($"SplittAttack at {targetUnit.PositionLog()} to {possibleAttackFields.Count} Fields: {unitsPerField} + rest {rest} | Pressure {targetUnit.Pressure} + cast {targetUnit.PressureChangeForecast}");

        foreach (Field f in possibleAttackFields)
        {
            int unitCount = unitsPerField;
            if (rest > 0)
                unitCount += 1;
            command += ActionsBuilder.Move (targetUnit, f, unitCount);
            rest--;
        }

    }

    void ConquereMapOnStuck ()
    {
        Console.Error.WriteLine ($"ChangeCounter {nothingChangedCounter}");
        if (Conquering)
        {
            HashSet<Field> disscoverdSet = new ();
            HashSet<Field> currentSet = new ();
            HashSet<Field> checkedSet = new ();
            Dictionary<Field, Field> discoverList = new ();
            currentSet.Add (conquereUnit);
            while (currentSet.Count != 0)
            {
                foreach (Field checkField in currentSet)
                {
                    checkedSet.Add (checkField);
                    foreach (Field next in checkField.GetPossibleMoveDirection (gameBoard))
                    {
                        if (next == conquereUnit)
                            continue;
                        Console.Error.Write (next.PositionLog () + ", ");
                        if (!discoverList.ContainsKey (next))
                            discoverList.Add (next, checkField);
                        if (!next.mine && !next.enemies)
                        {
                            Field backtrackingField = next;
                            while (discoverList.ContainsKey (backtrackingField))
                            {
                                if (conquereUnit == discoverList[backtrackingField])
                                    break;
                                backtrackingField = discoverList[backtrackingField];
                            }
                            Console.Error.WriteLine ($"conquereUnit {conquereUnit.PositionLog()} to {next.PositionLog()} over {backtrackingField.PositionLog()}");
                            command += ActionsBuilder.Move (conquereUnit, backtrackingField, 1);
                            conquereUnit = backtrackingField;
                            return;
                        }
                        if (!next.enemies && !checkedSet.Contains (next) && !disscoverdSet.Contains (next))
                        {
                            disscoverdSet.Add (next);
                        }
                    }
                }
                currentSet.Clear ();

                foreach (Field f in disscoverdSet)
                    currentSet.Add (f);
                disscoverdSet.Clear ();
            }
            Conquering = false;
            nothingChangedCounter = 0;
        }

        if (oldPoints == gameBoard.MyFields.Count)
            nothingChangedCounter++;
        else
        {
            nothingChangedCounter = 0;
        }

        if (nothingChangedCounter >= Settings.StartConquereAfterSteps)
        {
            List<Field> spawnAtFree = new ();
            foreach (Field buildField in gameBoard.MyFields)
            {
                if (buildField.GoodSpawn)
                {
                    command += ActionsBuilder.Spawn (buildField, 1);
                    conquereUnit = buildField;
                    Conquering = true;
                    gameBoard.MyMatter -= Consts.BuildCost;
                    Console.Error.WriteLine ("spawning C-Unit " + buildField.PositionLog ());
                    break;
                }
            }
        }
        oldPoints = gameBoard.MyFields.Count;
    }
}

