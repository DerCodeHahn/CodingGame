using System;
using System.Text;
using System.Linq;
using System.IO;
using System.Numerics;
using System.Collections;
using System.Collections.Generic;
/*
ActionsBuilder.cs
*/


static class ActionsBuilder
{
    const string BUILD = "BUILD";
    const string MOVE = "MOVE";
    const string SPAWN = "SPAWN";
    const string WAIT = "WAIT";
    const string MESSAGE = "MESSAGE";

    public static string Build (Field field)
    {
        return $"{BUILD} {field.PositionLog()};";
    }

    public static string Spawn (Field field, int amount)
    {
        return $"{SPAWN} {amount} {field.PositionLog()};";
    }

    public static string Move (Field from, Field to, int amount)
    {
        return $"{MOVE} {amount} {from.PositionLog} {to.PositionLog};";
    }

    public static string Move (byte fromX ,byte fromY , byte toX ,byte toY , int amount)
    {
        return $"{MOVE} {amount} {fromX} {fromY} {toX} {toY};";
    }

    public static string Wait ()
    {
        return WAIT;
    }

}


/*
Consts.cs
*/

static class Consts
{
    public static int BuildCost = 10;
    public static int IncomePerRound = 10;
}


/*
Field.cs
*/


struct Field
{
    public byte X;
    public byte Y;
    public byte scrapAmount;
    public bool mine;
    public bool enemies;
    public byte units;
    public bool recycler;
    public bool canBuild;
    public bool canSpawn;
    public bool inRangeOfRecycler;
    public byte TotalCollectableScrap;
    public bool SuroundingStays;
    public bool GoodSpawn;

    public Field(byte x, byte y, byte scrapAmount, bool mine, bool enemies, byte units, bool recycler, bool canBuild, bool canSpawn, bool inRangeOfRecycler)
    {
        X = x;
        Y = y;
        this.scrapAmount = scrapAmount;
        this.mine = mine;
        this.enemies = enemies;
        this.units = units;
        this.recycler = recycler;
        this.canBuild = canBuild;
        this.canSpawn = canSpawn;
        this.inRangeOfRecycler = inRangeOfRecycler;
        TotalCollectableScrap = 0;
        SuroundingStays = false;
        GoodSpawn = false;
    }

    public static int SortByTotalCollectableScrap (Field x, Field y)
    {
        return x.TotalCollectableScrap.CompareTo (y.TotalCollectableScrap) * -1;
    }

    public string PositionLog ()
    {
        return $"{X} {Y}";
    }
}


/*
GameBoard.cs
*/


class GameBoard
{
    public static int width, height;
    public Field[, ] fields;

    public HashSet<Field> MyFields;
    public HashSet<Field> EnemieFields;
    public HashSet<Field> FreeField;

    public byte MyMatter;

    public List < (byte x, byte y, byte n) > MyUnits; //x,y, count

    public string CommandGettingHere;
    public float score;

    public List<Action> CurrentCommands = new List<Action> ();

    public Field this [int x, int y]
    {
        get { return fields[x, y]; }
        set { fields[x, y] = value; }
    }

    public GameBoard (Field[, ] fields)
    {
        this.fields = fields;
        MyFields = new ();
        EnemieFields = new ();
        FreeField = new ();
        MyUnits = new ();
        CommandGettingHere = "";
        MyMatter = 0;
    }

    public GameBoard (GameBoard board)
    {
        this.fields = board.fields;
        MyFields = board.MyFields;
        EnemieFields = board.EnemieFields;
        FreeField = board.FreeField;
        MyUnits = board.MyUnits;
        CommandGettingHere = board.CommandGettingHere;
        MyMatter = board.MyMatter;
    }

    public static int SortByScore (GameBoard board1, GameBoard board2) { return board1.score.CompareTo (board2.score); }

    public void Analize ()
    {
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                Field field = fields[x, y];
                if (field.scrapAmount == 0)
                    continue;

                GetSurroundingValues (ref field);

                if (field.mine)
                {
                    MyFields.Add (field);
                    if (field.units >= 1)
                        MyUnits.Add ((field.X, field.Y, field.units));
                }
                else if (field.enemies)
                    EnemieFields.Add (field);
                else
                    FreeField.Add (field);
            }
        }
        CalculateScore ();
    }

    private void CalculateScore ()
    {
        int verticalScore = VerticalScore ();

        int pureScore = MyFields.Count - EnemieFields.Count;
        score = pureScore + verticalScore / 2;
        Console.Error.WriteLine ($"Current Score : {score}");
    }

    int VerticalScore ()
    {
        HashSet<Field> set = new (); // use Set for perfomance unique
        foreach (var unit in MyUnits)
        {
            for (byte vPos = unit.x; vPos >= 0 && vPos < width; vPos = (byte) (vPos + Player.PlayDirection * -1)) // Looking back to my base
            {
                if (fields[vPos, unit.y].scrapAmount != 0) // take fields wich i can own into account
                {
                    bool isNew = set.Add (fields[vPos, unit.y]); // add unique to set
                    if (isNew) // if we found one we can skip the rest of the line
                        break;
                }
            }
        }
        set.ExceptWith (MyFields);
        return set.Count;
    }

    public List<Field> GetHigherSurroundingsFields ()
    {
        List<Field> mine = new List<Field> (MyFields);
        mine = mine.FindAll ((c) => { return c.SuroundingStays; });
        return mine;
    }

    public List<Field> GetSpawnFields ()
    {
        List<Field> spawns = new ();
        foreach (Field f in MyFields)
            if (f.GoodSpawn)
                spawns.Add (f);
        return spawns;
    }

    void GetSurroundingValues (ref Field field)
    {
        field.TotalCollectableScrap = field.scrapAmount;

        if (field.Y - 1 >= 0)
        {
            CheckNeighbour (ref field, 0, -1);
        }
        if (field.Y + 1 < height)
        {
            CheckNeighbour (ref field, 0, 1);
        }
        if (field.X - 1 >= 0)
        {
            CheckNeighbour (ref field, -1, 0);
        }
        if (field.X + 1 < width)
        {
            CheckNeighbour (ref field, 1, 0);
        }
    }

    private void CheckNeighbour (ref Field field, sbyte xdelta, sbyte ydelta)
    {
        Field neighbour = fields[field.X + xdelta, field.Y + ydelta];
        //Max Amount Clamped by own scrapAmount
        field.TotalCollectableScrap += Math.Clamp (neighbour.scrapAmount, (byte) 0, field.scrapAmount);

        if (!CheckForHigherSurrounding (field, neighbour))
            field.SuroundingStays = false;

        if (field.canSpawn && (neighbour.enemies || !neighbour.mine))
            field.GoodSpawn = true;
    }

    bool CheckForHigherSurrounding (Field field, Field surroundedField)
    {
        if (surroundedField.scrapAmount != 0 && surroundedField.scrapAmount <= field.scrapAmount)
            return false;
        else
            return true;
    }

    internal void ExecuteCommands (List<Action> moveCommands)
    {
        CurrentCommands = moveCommands;

        foreach (Action action in moveCommands)
        {
            action.Execute (this);
        }
        Analize (); // TODO : Coud move Everthing into Execute to not iterate over all Fields again
        //TODO: Increase Metal
        //TODO: Haverst Matel from colletors
    }

    public string GetBuildString ()
    {
        string command = "";
        foreach (Action action in CurrentCommands)
        {
            command += action.Build ();
        }
        return command;
    }

    // internal Field NextFree (Vector2 myUnit)
    // {
    //     List<Field> notmine = new List<Field> (EnemieFields);
    //     notmine.AddRange (FreeField);
    //     float MinDistance = float.MaxValue;
    //     Field clostest = new Field ();
    //     foreach (Field field in notmine)
    //     {
    //         float distance = Vector2.Distance (field.position, myUnit);
    //         if (distance < MinDistance)
    //         {
    //             MinDistance = distance;
    //             clostest = field;
    //         }
    //     }
    //     return clostest;
    // }
}


/*
mainCode.cs
*/


public enum GamePhase
{
    Early,
    Mid,
    Late
}

class Player
{
    public static sbyte PlayDirection = 1; // 1 to right , -1 to left
    public static byte middle;
    public static bool Init = false;
    static (sbyte, sbyte) [] MoveDirections = new (sbyte, sbyte) []
    {
        (0, -1), (0, 1), (-1, 0), (1, 0)
    }; //up,down,left,right
    public static Random random = new Random ();
    static void Main (string[] args)
    {
        string[] inputs;
        inputs = Console.ReadLine ().Split (' ');
        int width = int.Parse (inputs[0]);
        int height = int.Parse (inputs[1]);
        GameBoard.height = height;
        GameBoard.width = width;

        middle = (byte) (width / 2);
        Field[, ] fields = new Field[width, height];
        int SurroundingCounter = 10;
        // game loop
        while (true)
        {
            inputs = Console.ReadLine ().Split (' ');
            int myMatter = int.Parse (inputs[0]);
            int oppMatter = int.Parse (inputs[1]);
            fields = new Field[width, height];
            int complexity = 1;
            for (byte y = 0; y < height; y++)
            {
                for (byte x = 0; x < width; x++)
                {
                    inputs = Console.ReadLine ().Split (' ');
                    byte scrapAmount = byte.Parse (inputs[0]);
                    SByte owner = SByte.Parse (inputs[1]); // 1 = me, 0 = foe, -1 = neutral
                    bool mine = owner == 1;
                    bool enemies = owner == 0;
                    byte units = byte.Parse (inputs[2]);
                    bool recycler = int.Parse (inputs[3]) == 1;
                    bool canBuild = int.Parse (inputs[4]) == 1;
                    bool canSpawn = int.Parse (inputs[5]) == 1;
                    bool inRangeOfRecycler = int.Parse (inputs[6]) == 1;
                    fields[x, y] = new Field (x, y, scrapAmount, mine, enemies, units, recycler, canBuild, canSpawn, inRangeOfRecycler);
                }
            }

            GameBoard gameBoard = new GameBoard (fields);
            gameBoard.Analize ();

            if (!Init)
                FindMatchData (gameBoard);

            string command = "";
            HashSet<Field> alreadyTargets = new HashSet<Field> ();

            if (myMatter >= Consts.BuildCost)
            {
                List<Field> higherSurroundingFields = gameBoard.GetHigherSurroundingsFields ();
                foreach (Field field in higherSurroundingFields)
                {
                    if (field.canBuild && SurroundingCounter > 0 && myMatter >= Consts.BuildCost && field.TotalCollectableScrap >= 20)
                    {
                        myMatter -= 10;
                        SurroundingCounter--;
                        command += ActionsBuilder.Build (field);
                    }
                }
                int count = myMatter / Consts.BuildCost;
                for (var i = 0; i < count; i++)
                {
                    List<Field> spawns = gameBoard.GetSpawnFields ();

                    //command += Actions.Spawn (spawns[rnd.Next (spawns.Count)], 1);
                    //complexity *= spawns.Count;
                }

            }

            //gameBoard.CommandGettingHere = command;
            PopulateGameBoards(gameBoard, 0);

            Console.WriteLine (nextGameBoards[0].GetBuildString());

        }
    }

    static List<GameBoard> nextGameBoards = new ();

    static void PopulateGameBoards (GameBoard board, int depth)
    {
        for (int i = 0; i <= 100; i++)
        {
            GameBoard next = new GameBoard (board);
            List<Action> moveCommands = new();

            foreach ((byte x, byte y, byte count) myUnit in board.MyUnits)
            {
                (sbyte x, sbyte y) direction = MoveDirections[random.Next (MoveDirections.Length)];
                //TODO Check for correct movement
                moveCommands.Add(new Move(myUnit.x, myUnit.y, (byte) (myUnit.x + direction.x), (byte) (myUnit.y + direction.y), myUnit.count));

                //moveCommands += ActionsBuilder.Move (myUnit.x, myUnit.y, (byte) (myUnit.x + direction.x), (byte) (myUnit.y + direction.y), myUnit.count);
            }
            //next.CurrentCommands = moveCommands;
            next.ExecuteCommands(moveCommands);
            nextGameBoards.Add (next);
        }
        nextGameBoards.Sort(GameBoard.SortByScore); // Maybe use directly sorted Structure ?

        for(int i = 0; i < 10; i++){
            Console.Error.WriteLine(nextGameBoards[i].score);
        }

    }

    private static void FindMatchData (GameBoard board)
    {
        Init = true;
        Field someOfMyFields = board.MyFields.First ();
        if (someOfMyFields.X >= middle)
            PlayDirection = -1;
        else
            PlayDirection = 1;

        Console.Error.WriteLine ($"PlayDirection {PlayDirection}");
    }
}


/*
Actions\Action.cs
*/

abstract class Action
{
    abstract public string Build ();
    abstract public void Execute (GameBoard board);

}


/*
Actions\Move.cs
*/

class Move : Action
{
    byte x, y, toX, toY, amount;

    public Move(byte x, byte y, byte toX, byte toY, byte amount)
    {
        this.x = x;
        this.y = y;
        this.toX = toX;
        this.toY = toY;
        this.amount = amount;
    }

    public override void Execute (GameBoard board)
    {
        Field newField = board[toX, toY];
        if (newField.scrapAmount == 0 || newField.recycler)
        {
            Console.Error.WriteLine ($"IllegaleMove : {Build()}");
            return;
        }
        Field field = board[x, y];
        field.units -= amount;


        if (newField.enemies)
        {
            if (amount < newField.units)
                newField.units -= amount;
            else if (amount > newField.units)
            {
                newField.units = (byte)(amount - newField.units);
                newField.mine = true;
                newField.enemies = false;
            }
            else
            {
                newField.units = 0;
                newField.mine = false;
                newField.enemies = false;
            }
        }
        else
        {
            newField.units = amount;
            newField.mine = true;
        }

        board[x, y] = field;
        board[toX, toY] = newField;
    }

    public override string Build ()
    {
        return ActionsBuilder.Move (x, y, toX, toY, amount);
    }
}

