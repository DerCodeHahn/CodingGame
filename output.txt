using System.Numerics;
using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text;
/*
ActionsBuilder.cs
*/


static class ActionsBuilder
{
    const string BUILD = "BUILD";
    const string MOVE = "MOVE";
    const string SPAWN = "SPAWN";
    const string WAIT = "WAIT";
    const string MESSAGE = "MESSAGE";

    public static string Build (Field field)
    {
        return $"{BUILD} {field.PositionLog()};";
    }

    public static string Spawn (Field field, int amount)
    {
        return $"{SPAWN} {amount} {field.PositionLog()};";
    }

    public static string Move (Field from, Field to, int amount)
    {
        return $"{MOVE} {amount} {from.PositionLog()} {to.PositionLog()};";
    }

    public static string Move (Field from, int toX ,int toY , int amount)
    {
        return $"{MOVE} {amount} {from.PositionLog()} {toX} {toY};";
    }

    public static string Move (byte fromX ,byte fromY , byte toX ,byte toY , int amount)
    {
        return $"{MOVE} {amount} {fromX} {fromY} {toX} {toY};";
    }

    public static string Wait ()
    {
        return WAIT;
    }

}


/*
Consts.cs
*/

static class Consts
{
    public static int BuildCost = 10;
    public static int IncomePerRound = 10;
}


/*
Field.cs
*/


struct Field
{
    public byte X;
    public byte Y;
    public byte scrapAmount;
    public bool mine;
    public bool enemies;
    public byte units;
    public bool recycler;
    public bool canBuild;
    public bool canSpawn;
    public bool inRangeOfRecycler;
    public byte TotalCollectableScrap;
    public bool SuroundingStays;
    public bool GoodSpawn;

    static (sbyte x, sbyte y) [] MoveDirections = new (sbyte, sbyte) []
    {
        (0, -1), (0, 1), (-1, 0), (1, 0)
    };

    public Field (byte x, byte y, byte scrapAmount, bool mine, bool enemies, byte units, bool recycler, bool canBuild, bool canSpawn, bool inRangeOfRecycler)
    {
        X = x;
        Y = y;
        this.scrapAmount = scrapAmount;
        this.mine = mine;
        this.enemies = enemies;
        this.units = units;
        this.recycler = recycler;
        this.canBuild = canBuild;
        this.canSpawn = canSpawn;
        this.inRangeOfRecycler = inRangeOfRecycler;
        TotalCollectableScrap = 0;
        SuroundingStays = false;
        GoodSpawn = false;
    }

    public static int SortByTotalCollectableScrap (Field x, Field y)
    {
        return x.TotalCollectableScrap.CompareTo (y.TotalCollectableScrap) * -1;
    }

    public string PositionLog ()
    {
        return $"{X} {Y}";
    }

    public string Info()
    {
        return $"{PositionLog()} scrap {scrapAmount} mine {mine} enemies {enemies} units {units} recycler {recycler} canBuild {canBuild}";
    }


    public List < (sbyte, sbyte) > GetNeighbourDirection ()
    {
        List < (sbyte, sbyte) > possibleDirection = new ();
        foreach ((sbyte x, sbyte y) direction in MoveDirections)
        {
            byte x = (byte) (X + direction.x);
            byte y = (byte) (Y + direction.y);

            if (x > 0 && y > 0 && x < GameBoard.width && y < GameBoard.height)
                possibleDirection.Add(direction);
        }
        return possibleDirection;
    }

    public List < (sbyte, sbyte) > GetPossibleMoveDirection (GameBoard board)
    {
        List < (sbyte, sbyte) > possibleDirection = new();
        foreach ((sbyte x, sbyte y) direction in GetNeighbourDirection())
        {
            byte x = (byte) (X + direction.x);
            byte y = (byte) (Y + direction.y);

            Field targetField = board[x, y];
            if (targetField.scrapAmount != 0 && !targetField.recycler)
            {
                possibleDirection.Add (direction);
            }
        }

        return possibleDirection;
    }
}


/*
GameBoard.cs
*/


class GameBoard
{
    public static int width, height;
    public Field[, ] fields;

    public HashSet<Field> MyFields;
    public HashSet<Field> EnemieFields;
    public HashSet<Field> FreeField;

    public int MyMatter;

    public List <Field> MyUnits;

    public string CommandGettingHere;
    public float score;

    public List<Action> CurrentCommands = new List<Action> ();

    public Field this [int x, int y]
    {
        get { return fields[x, y]; }
        set { fields[x, y] = value; }
    }

    public GameBoard (Field[, ] fields)
    {
        this.fields = fields;
        MyFields = new ();
        EnemieFields = new ();
        FreeField = new ();
        MyUnits = new ();
        CommandGettingHere = "";
        MyMatter = 0;
    }

    public GameBoard (GameBoard board)
    {
        fields = (Field[, ]) board.fields.Clone ();
        MyFields = board.MyFields;
        EnemieFields = new HashSet<Field> ();
        FreeField = new HashSet<Field> ();
        MyUnits = new List < Field > ();
        CommandGettingHere = board.CommandGettingHere;
        MyMatter = board.MyMatter;
        CurrentCommands = new List<Action> ();
    }

    public static int SortByScore (GameBoard board1, GameBoard board2)
    {
        return board1.score.CompareTo (board2.score) * -1;
    }

    public void Analize ()
    {
        MyFields.Clear ();
        EnemieFields.Clear ();
        FreeField.Clear ();

        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                Field field = fields[x, y];
                if (field.scrapAmount == 0)
                    continue;

                GetSurroundingValues (ref field);

                if (field.mine)
                {
                    MyFields.Add (field);
                    if (field.units >= 1)
                        MyUnits.Add ((field));
                }
                else if (field.enemies)
                    EnemieFields.Add (field);
                else
                    FreeField.Add (field);
            }
        }
        CalculateScore ();
    }

    private void CalculateScore ()
    {
        int verticalScore = VerticalScore ();

        int pureScore = MyFields.Count - EnemieFields.Count;
        score = pureScore + verticalScore / 2;
        //Console.Error.WriteLine ($"Current Score : {score} : MyFields {MyFields.Count} , Enemie {EnemieFields.Count}, MyUnits :{MyUnits.Count}");
    }

    int VerticalScore ()
    {
        HashSet<Field> set = new (); // use Set for perfomance unique
        foreach (var unit in MyUnits)
        {
            for (byte vPos = unit.X; vPos >= 0 && vPos < width; vPos = (byte) (vPos + Player.PlayDirection * -1)) // Looking back to my base
            {
                if (fields[vPos, unit.Y].scrapAmount != 0) // take fields wich i can own into account
                {
                    bool isNew = set.Add (fields[vPos, unit.Y]); // add unique to set
                    if (isNew) // if we found one we can skip the rest of the line
                        break;
                }
            }
        }
        set.ExceptWith (MyFields);
        return set.Count;
    }

    public List<Field> GetHigherSurroundingsFields ()
    {
        List<Field> mine = new List<Field> (MyFields);
        mine = mine.FindAll ((c) => { return c.SuroundingStays; });
        return mine;
    }

    public List<Field> GetSpawnFields ()
    {
        List<Field> spawns = new ();
        foreach (Field f in MyFields)
            if (f.GoodSpawn)
                spawns.Add (f);
        return spawns;
    }

    void GetSurroundingValues (ref Field field)
    {
        field.TotalCollectableScrap = field.scrapAmount;
        field.SuroundingStays = true;

        foreach ((sbyte x, sbyte y) direction in field.GetNeighbourDirection ())
        {
            CheckNeighbour (ref field, direction);
        }
    }

    private void CheckNeighbour (ref Field field, (sbyte x, sbyte y) delta)
    {
        Field neighbour = fields[field.X + delta.x, field.Y + delta.y];
        //Max Amount Clamped by own scrapAmount
        field.TotalCollectableScrap += Math.Clamp (neighbour.scrapAmount, (byte) 0, field.scrapAmount);

        if (!CheckForHigherSurrounding (field, neighbour))
            field.SuroundingStays = false;

        if (field.canSpawn && (neighbour.enemies || !neighbour.mine))
            field.GoodSpawn = true;
    }

    bool CheckForHigherSurrounding (Field field, Field surroundedField)
    {
        if (surroundedField.scrapAmount != 0 && surroundedField.scrapAmount <= field.scrapAmount)
            return false;
        else
            return true;
    }

    internal void ExecuteCommands (List<Action> moveCommands)
    {
        CurrentCommands = moveCommands;

        foreach (Action action in moveCommands)
        {
            action.Execute (this);
        }
        Analize (); // TODO : Coud move Everthing into Execute to not iterate over all Fields again
        //TODO: Increase Metal
        //TODO: Haverst Matel from colletors
    }

    public string GetBuildString ()
    {
        string command = "";
        foreach (Action action in CurrentCommands)
        {
            command += action.Build ();
        }
        return command;
    }

    // internal Field NextFree (Vector2 myUnit)
    // {
    //     List<Field> notmine = new List<Field> (EnemieFields);
    //     notmine.AddRange (FreeField);
    //     float MinDistance = float.MaxValue;
    //     Field clostest = new Field ();
    //     foreach (Field field in notmine)
    //     {
    //         float distance = Vector2.Distance (field.position, myUnit);
    //         if (distance < MinDistance)
    //         {
    //             MinDistance = distance;
    //             clostest = field;
    //         }
    //     }
    //     return clostest;
    // }
}


/*
mainCode.cs
*/


class Player
{
    public static sbyte PlayDirection = 1; // 1 to right , -1 to left
    public static Field MyBasePosition;
    public static Field EnemyBasePosition;
    public static byte middle;
    public static bool Init = false;
    public static int GameStep = 0;

    static (sbyte, sbyte) [] MoveDirections = new (sbyte, sbyte) []
    {
        (0, -1), (0, 1), (-1, 0), (1, 0)
    }; //up,down,left,right
    public static Random random = new Random ();
    static void Main (string[] args)
    {
        string[] inputs;
        inputs = Console.ReadLine ().Split (' ');
        int width = int.Parse (inputs[0]);
        int height = int.Parse (inputs[1]);
        GameBoard.height = height;
        GameBoard.width = width;

        middle = (byte) (width / 2);
        Field[, ] fields = new Field[width, height];
        int SurroundingCounter = 10;
        GamePhase gamePhase = new EarlyGame ();

        // game loop
        while (true)
        {
            GameStep++;
            inputs = Console.ReadLine ().Split (' ');
            int myMatter = int.Parse (inputs[0]);
            int oppMatter = int.Parse (inputs[1]);
            fields = new Field[width, height];
            int complexity = 1;
            for (byte y = 0; y < height; y++)
            {
                for (byte x = 0; x < width; x++)
                {
                    inputs = Console.ReadLine ().Split (' ');
                    byte scrapAmount = byte.Parse (inputs[0]);
                    SByte owner = SByte.Parse (inputs[1]); // 1 = me, 0 = foe, -1 = neutral
                    bool mine = owner == 1;
                    bool enemies = owner == 0;
                    byte units = byte.Parse (inputs[2]);
                    bool recycler = int.Parse (inputs[3]) == 1;
                    bool canBuild = int.Parse (inputs[4]) == 1;
                    bool canSpawn = int.Parse (inputs[5]) == 1;
                    bool inRangeOfRecycler = int.Parse (inputs[6]) == 1;
                    fields[x, y] = new Field (x, y, scrapAmount, mine, enemies, units, recycler, canBuild, canSpawn, inRangeOfRecycler);
                }
            }

            GameBoard gameBoard = new GameBoard (fields);
            gameBoard.MyMatter = myMatter;
            gameBoard.Analize ();

            if (!Init)
                FindMatchData (gameBoard);

            gamePhase.Execute (gameBoard);

            //nextGameBoards.Clear();
            //gameBoard.CommandGettingHere = command;

            //Console.WriteLine (nextGameBoards[0].GetBuildString ());

        }
    }

    static List<GameBoard> nextGameBoards = new ();

    static void PopulateGameBoards (GameBoard board, int depth)
    {
        for (int i = 0; i <= 100; i++)
        {
            GameBoard next = new GameBoard (board);
            List<Action> moveCommands = new ();
            foreach (Field myUnit in board.MyUnits)
            {
                List < (sbyte, sbyte) > possibleDirection = board[myUnit.X, myUnit.Y].GetPossibleMoveDirection (board);
                if (possibleDirection.Count == 0)
                    continue;
                (sbyte x, sbyte y) direction = possibleDirection[random.Next (possibleDirection.Count)];

                moveCommands.Add (new Move (myUnit.X, myUnit.Y, (byte) (myUnit.X + direction.x), (byte) (myUnit.Y + direction.y), myUnit.units));

                //moveCommands += ActionsBuilder.Move (myUnit.x, myUnit.y, (byte) (myUnit.x + direction.x), (byte) (myUnit.y + direction.y), myUnit.count);
            }

            //next.CurrentCommands = moveCommands;
            next.ExecuteCommands (moveCommands);
            nextGameBoards.Add (next);
        }
        nextGameBoards.Sort (GameBoard.SortByScore); // Maybe use directly sorted Structure ?

        for (int i = 0; i < 10; i++)
        {
            Console.Error.WriteLine ($"{nextGameBoards[i].score} {nextGameBoards[i].GetBuildString()}");
        }

    }

    private static void FindMatchData (GameBoard board)
    {
        Init = true;
        foreach (Field field in board.EnemieFields)
            if (field.units == 0)
                EnemyBasePosition = field;

        foreach (Field field in board.MyFields)
            if (field.units == 0)
                MyBasePosition = field;

        if (MyBasePosition.X >= middle)
            PlayDirection = -1;
        else
            PlayDirection = 1;
    }
}


/*
Settings.cs
*/

static class Settings
{
    public static float maxTimeForCalc = 48;
}


/*
UTIL.cs
*/

static class UTIL
{
    public static int Distance (Field a, Field b)
    {
        return Math.Abs(a.X - b.X) +  Math.Abs(a.X - b.X);
    }

    public static int Distance (Field a, (int X, int Y) b)
    {
        return Math.Abs(a.X - b.X) +  Math.Abs(a.X - b.X);
    }
}


/*
Actions\Action.cs
*/

abstract class Action
{
    abstract public string Build ();
    abstract public void Execute (GameBoard board);

}


/*
Actions\Move.cs
*/

class Move : Action
{
    byte x, y, toX, toY, amount;

    public Move (byte x, byte y, byte toX, byte toY, byte amount)
    {
        this.x = x;
        this.y = y;
        this.toX = toX;
        this.toY = toY;
        this.amount = amount;
    }

    public override void Execute (GameBoard board)
    {
        Field newField = board[toX, toY];
        if (newField.scrapAmount == 0 || newField.recycler)
        {
            Console.Error.WriteLine ($"IllegaleMove : {Build()}");
            return;
        }
        Field field = board[x, y];
        field.units -= amount;

        if (newField.enemies)
        {
            if (amount < newField.units)
                newField.units -= amount;
            else if (amount > newField.units)
            {
                newField.units = (byte) (amount - newField.units);
                newField.mine = true;
                newField.enemies = false;
            }
            else
            {
                newField.units = 0;
            }
        }
        else
        {
            newField.units = amount;
            newField.mine = true;
        }

        board[x, y] = field;
        board[toX, toY] = newField;
        //Console.Error.WriteLine ("Old :" + field.Info ());
        //Console.Error.WriteLine ("New :" + newField.Info ());
    }

    public override string Build ()
    {
        return ActionsBuilder.Move (x, y, toX, toY, amount);
    }
}


/*
GamePhase\EarlyGame.cs
*/

class EarlyGame : GamePhase
{
    string command = "";

    public override void Execute (GameBoard gameBoard)
    {
        base.Execute (gameBoard);
        command = "";

        BuildSpeedUps ();
        BuildArmee ();
        MoveFromAttackPoint ();
        Console.WriteLine (command);
    }

    void BuildSpeedUps ()
    {
        if (gameBoard.MyMatter >= Consts.BuildCost)
        {
            List<Field> higherSurroundingFields = gameBoard.GetHigherSurroundingsFields ();
            foreach (Field field in higherSurroundingFields)
            {
                if (field.canBuild && gameBoard.MyMatter >= Consts.BuildCost && field.TotalCollectableScrap >= 20)
                {
                    gameBoard.MyMatter -= 10;
                    command += ActionsBuilder.Build (field);
                }
            }
        }
    }

    void BuildArmee ()
    {
        if (gameBoard.MyMatter >= Consts.BuildCost)
        {
            int max = rowMappedFields.Keys.Max ();
            int min = rowMappedFields.Keys.Min ();

            int bestIndexMax = Player.PlayDirection == 1 ? rowMappedFields[max].Count - 1 : 0;
            int bestIndexMin = Player.PlayDirection == 1 ? rowMappedFields[min].Count - 1 : 0;

            bool canSpawnOnBothSides = gameBoard.MyMatter >= Consts.BuildCost * 2;
            bool maxRowFree = (max != GameBoard.height - 1);
            bool minRowFree = (min != 0);

            Console.Error.WriteLine ($"in {max} von {GameBoard.height - 1} = free {maxRowFree}");
            if (maxRowFree)
                if (canSpawnOnBothSides || !canSpawnOnBothSides && Player.GameStep % 2 == 0)
                    //if (!gameBoard.MyUnits.Contains (rowMappedFields[max][bestIndexMax]))
                    command += ActionsBuilder.Spawn (rowMappedFields[max][bestIndexMax], 1);

            if (minRowFree)
                if (canSpawnOnBothSides || !canSpawnOnBothSides && Player.GameStep % 2 == 1 && minRowFree)
                    //if (!gameBoard.MyUnits.Contains (rowMappedFields[min][bestIndexMin]))
                    command += ActionsBuilder.Spawn (rowMappedFields[min][bestIndexMin], 1);

        }
    }

    void MoveFromAttackPoint ()
    {
        Dictionary<Field, int> AlreadySelected = new Dictionary<Field, int> ();
        //TODO : loop from center to borders
        Field AttackPoint = gameBoard[Player.middle, Player.MyBasePosition.Y];
        Console.Error.WriteLine ($"base at {Player.MyBasePosition.Y}: {AttackPoint.PositionLog()}");

        Field bestAttackField = Player.MyBasePosition;
        int minDistance = 100;
        foreach (Field unit in gameBoard.MyUnits)
        {
            if (AlreadySelected.ContainsKey (unit) && AlreadySelected[unit] <= 0)
                continue;
            int distance = L2Distance (AttackPoint, unit);
            Console.Error.WriteLine ($"{unit.PositionLog()} in {distance}");
            if (distance < minDistance)
            {
                bestAttackField = unit;
                minDistance = distance;
            }
        }
        foreach (Field spawn in gameBoard.GetSpawnFields ())
        {
            int distance = L2Distance (AttackPoint, spawn) + 2;
            if (distance < minDistance)
            {
                bestAttackField = spawn;
                minDistance = distance;
            }
        }
        Console.Error.WriteLine ($" Best Field {bestAttackField.PositionLog()} ");
        bool foundMoveFieldBefore = AlreadySelected.ContainsKey (bestAttackField);
        if (bestAttackField.units != 0 && (foundMoveFieldBefore && AlreadySelected[bestAttackField] < bestAttackField.units) || !foundMoveFieldBefore)
        {
            if (!foundMoveFieldBefore)
                AlreadySelected.Add (bestAttackField, bestAttackField.units);
            AlreadySelected[bestAttackField]--;
            command += ActionsBuilder.Move (bestAttackField, AttackPoint, 1);
        }
        else if (bestAttackField.units == 0 || foundMoveFieldBefore && AlreadySelected[bestAttackField] == bestAttackField.units)
        {
            command += ActionsBuilder.Spawn (bestAttackField, 1);
        }
    }

    int L2Distance (Field field, Field other)
    {
        return Math.Abs (field.X - other.X) + Math.Abs (field.Y - other.Y);
    }

    void Move ()
    {
        foreach (List<Field> fields in rowMappedUnits.Values)
        {
            bool first = true;
            if (Player.PlayDirection == 1)
                fields.Reverse ();

            foreach (Field field in fields)
            {
                int AwayCenterDirection = Math.Clamp (field.Y.CompareTo (Player.MyBasePosition.Y), -1, 1);
                Console.Error.WriteLine ($"base at {Player.MyBasePosition.Y}: {field.PositionLog() } {AwayCenterDirection}");
                for (int i = 0; i < field.units; i++)
                {
                    //TODO LOOP as long as Fields are not possible
                    if (first)
                    {
                        first = false;
                        command += ActionsBuilder.Move (field, field.X + Player.PlayDirection, field.Y, 1);
                    }
                    else
                    {
                        first = true;
                        //Assume the way is blocked so search
                        Field TargetField = gameBoard[field.X, field.Y + AwayCenterDirection];
                        bool found = FindNextFreeFieldInRow (TargetField, out Field newTarget);
                        if (found)
                            command += ActionsBuilder.Move (field, field.X, field.Y + AwayCenterDirection, 1);
                        else
                            Console.Error.WriteLine ("EndReached");

                    }
                }
            }
        }

        //moveCommands += ActionsBuilder.Move (myUnit.x, myUnit.y, (byte) (myUnit.x + direction.x), (byte) (myUnit.y + direction.y), myUnit.count);
    }

    bool FindNextFreeFieldInRow (Field field, out Field newTarget)
    {
        newTarget = field;
        for (int x = field.X; x >= 0 && x < GameBoard.width; x += Player.PlayDirection)
        {
            Field TargetField = gameBoard[x, field.Y];
            if (TargetField.mine || TargetField.scrapAmount == 0)
            {
                newTarget = TargetField;
                return true;
            }
        }
        return false;
    }

    protected override bool CheckTransition ()
    {
        return false;
    }

    protected override GamePhase Transition ()
    {
        return new EarlyGame ();
    }
}


/*
GamePhase\GamePhase.cs
*/

class GamePhase
{
    protected GameBoard gameBoard;


    protected Dictionary<int, List<Field>> rowMappedUnits;
    protected Dictionary<int, List<Field>> rowMappedFields;


    virtual public void Execute (GameBoard board)
    {
        this.gameBoard = board;

        rowMappedUnits = RowMapMyUnits();
        rowMappedFields = RowMapMyFields();
    }

    virtual protected bool CheckTransition ()
    {
        return false;
    }

    virtual protected GamePhase Transition ()
    {
        return this;
    }

    protected Dictionary<int, List<Field>> RowMapMyUnits()
    {
        Dictionary<int, List<Field>> rowMappedUnits = new Dictionary<int, List<Field>>();

        foreach (Field myUnit in gameBoard.MyUnits)
        {
            if (!rowMappedUnits.ContainsKey(myUnit.Y))
                rowMappedUnits.Add(myUnit.Y, new List<Field>());
            rowMappedUnits[myUnit.Y].Add(myUnit);
        }

        return rowMappedUnits;
    }

    protected Dictionary<int, List<Field>> RowMapMyFields()
    {
        Dictionary<int, List<Field>> rowMappedUnits = new Dictionary<int, List<Field>>();

        foreach (Field field in gameBoard.MyFields)
        {
            if (!rowMappedUnits.ContainsKey(field.Y))
                rowMappedUnits.Add(field.Y, new List<Field>());
            rowMappedUnits[field.Y].Add(field);
        }

        return rowMappedUnits;
    }
}

